# 匯入
把所有程式碼放在單一檔案裡很快就會變得難以維護。
`import` 陳述式允許你從其他檔案匯入函式和全域變數。
下面用一張截圖說明運作原理：
![](ImportsInOnePicture400)

這裡的 `import module2` 會執行名為 `module2` 的檔案，並讓你存取該檔案中建立的所有全域變數。
你可以使用 `.` 運算子存取被匯入模組內的變數與函式。
所以在這個範例中，`module2.print_x()` 會呼叫 `module2` 中的 `print_x()`。

### 無須繼續閱讀

你也可以使用 `from` 語法，將被匯入模組的全域變數移到目前執行匯入陳述式所在的作用域。

```
from module2 import print_x
print_x()
```

只會匯入 `module2` 中指定的全域成員。

或者

```
from module2 import *
print_x()
```

匯入 `module2` 中的所有全域成員。

這同樣會匯入 `module2` 檔案，但不再透過名為 `module2` 的變數來存取，而是將 `module2` 的全域成員展開並直接指派到本地作用域。

通常不建議使用這種匯入方式，因為當兩個檔案互相匯入時，這種方式效果不佳，而且由於名稱衝突，可能會意外覆蓋匯入檔案中的變數。如果你不清楚自己在做什麼，最好避免使用 `from` 語法。

# 實際運作方式

## 重點摘要
匯入行為有時並不直觀，但大多數問題可透過堅持使用 `import file` 語法，而非 `from file import`，並將非全域定義的程式碼包在：

```
if __name__ == "__main__":
```

就可以避免大多數問題。

## 匯入的副作用
第一次匯入某個檔案時，會執行整個檔案，然後回傳在執行期間被定義的所有變數。如果再次匯入同一個檔案，則會回傳第一次匯入時快取的模組物件，而不會再次執行檔案。

這表示匯入陳述式可能會產生副作用。例如，如果你匯入的檔案中呼叫了 `harvest()` ，那在匯入時就會執行採收；但當你再次匯入該檔案時，因為模組只會執行一次，所以不會再次採收。

可以使用 `__name__` 變數來避免這類副作用。此變數在直接執行檔案時會自動設為 `"__main__"`，而在透過 `import` 執行時會被設為該檔案的名稱。良好作法是將不希望在匯入時執行的程式碼放在 `if __name__ == "__main__":` 的區塊中。

在 Python 中常見的檔案結構是把當檔案被直接執行時應執行的程式碼放入一個 `main()` 函式，藉此清楚區分本地變數（定義於 `main()` 内）和可被匯入的全域變數（定義於 `main()` 外）。

```
a_global_variable = "global"

def main():
    a_local_variable = "local"
    # 執行某些操作

if __name__ == "__main__":
    main()
```

## 匯入迴圈
如果檔案 `a` 匯入檔案 `b`，而檔案 `b` 又匯入檔案 `a`，會發生什麼事？

檔案 `a`：

```
import b
x = 0
```

檔案 `b`：
```
import a
def f():
    print(a.x)
```

這種情況其實可以正常運作。假設兩個檔案都還沒被載入，且某人執行 `import a`。

- `a` 執行到 `import b` 這一行時暫停。
- `b` 執行到 `import a` 這一行時暫停。
- 此時模組 `a` 已经存在，但尚未包含 `x`，因為它只執行到 `import b` 這一行。
- `b` 會將半載入的模組 `a` 的參考儲存在變數 `a` 中。
- `b` 接著執行 `def` 陳述式並儲存函式 `f()`。
- `a` 繼續執行並初始化 `x`。

當有地方呼叫 `b.f()` 時，會正確印出 `0`，因為 `b` 所持有的 `a` 參考此時已經是完整載入的模組。

現在如果改用 `from` 語法，情況就不同了。

檔案 `a`：
```
from b import *
x = 0
```

檔案 `b`：
```
from a import *
def f():
    print(x)
```

- `a` 執行到 `from b import *` 這一行時暫停。
- `b` 執行到 `from a import *` 這一行時暫停。
- 此時模組 `a` 已经存在，但尚未完全執行完畢。
- `b` 會將目前 `a` 中存在的所有名稱解包到自己的全域作用域。但此時 `a` 為空，因為它尚未執行到 `x = 0` 這行程式碼，因此沒有內容被匯入。
- `b` 接著執行 `def` 陳述式並儲存函式 `f()`。
- `a` 繼續執行並初始化 `x`。

如果此時有地方呼叫 `b.f()`，則會發生錯誤，指出 `x` 在目前作用域中不存在。原因在於這次 `b` 並沒有持有對仍在載入中的 `a` 的參考，因此無法存取匯入後才加入的定義。
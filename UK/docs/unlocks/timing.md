# Таймінг
Якщо ви справді хочете оптимізувати свої методи, вам потрібно зрозуміти, як вимірюється час у цій грі. Це розблокування присвячене саме цьому.

## Нові функції
Є дві корисні функції для вимірювання того, скільки часу займають ті чи інші дії:

`get_time()` повертає час у секундах з моменту початку гри.

`get_tick_count()` повертає кількість тіків, виконаних з моменту початку виконання програми.

Ці дві функції, а також `quick_print()`, є миттєвими. Операція їх виклику не займає часу.

## Деталі часу виконання

### Попередження
Це не те, як працює продуктивність у реальному світі. Це просто правила, створені для цієї гри, щоб мати послідовну та зрозумілу модель таймінгу.
Ймовірно, це зацікавить вас лише в тому випадку, якщо ви хочете гіпероптимізувати свій код.


Базовою одиницею часу для виконання коду є «тік». Без покращень швидкості та енергії виконання відбувається зі швидкістю `400` тіків на секунду.

Загалом, операції, що поєднують два значення, такі як `+, -, *, /, //, %, and, or, ...`, займають один тік.
Одиничне значення `-` та оператор `not` — миттєві.
Розгалуження `if` також займає один тік (додатково до часу, необхідного для обчислення значення умови).
Виклики функцій, а також читання та запис змінних — миттєві, але визначення функцій займає 1 тік.
Інструкції `import` миттєві.
Доступ до імпортованого модуля за допомогою оператора `.` — миттєвий.
Якщо функція або модуль були передані через аргументи або присвоєння змінних, їх використання коштуватиме 1 тік замість 0.
Цикли `for` та `while` займають один тік для запуску, але ітерації миттєві (не враховуючи час на обчислення виразу умови/послідовності).
`return`, `break` та `continue` — усі миттєві.
`pass` займає один тік, тому його можна використовувати для створення точних затримок.
Індексація в структурі даних займає один тік і, у випадку словника або множини, додаткові тіки залежно від розміру ключа.

Кількість тіків, які займають вбудовані функції, задокументована в описі кожної функції індивідуально.
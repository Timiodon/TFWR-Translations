# Лабіринти (Mazes)
`Items.Weird_Substance`, яку можна отримати шляхом [удобрювання](docs/unlocks/fertilizer.md) рослин, має дивний вплив на кущі. Якщо дрон знаходиться над кущем і ви викликаєте `use_item(Items.Weird_Substance, amount)`, кущ виросте в лабіринт із живоплоту.
Розмір лабіринту залежить від кількості використаної `Items.Weird_Substance` (другий аргумент виклику `use_item()`).
Без покращень лабіринту використання `n` одиниць `Items.Weird_Substance` призведе до створення лабіринту розміром `n`x`n`. Кожен рівень покращення лабіринту подвоює скарб, але також подвоює кількість необхідної `Items.Weird_Substance`. 
Отже, щоб створити лабіринт на все поле:

`plant(Entities.Bush)`
`substance = get_world_size() * 2**(num_unlocked(Unlocks.Mazes) - 1)`
`use_item(Items.Weird_Substance, substance)`


З певної причини дрон не може пролетіти над живоплотом, хоча він не виглядає надто високим.

Десь у живоплоті заховано скарб. Використовуйте `harvest()` на скарбі, щоб отримати золото в кількості, що дорівнює площі лабіринту. (Наприклад, лабіринт 5x5 дасть 25 одиниць золота.)

Якщо ви використаєте `harvest()` у будь-якому іншому місці, лабіринт просто зникне.

`get_entity_type()` дорівнює `Entities.Treasure`, якщо дрон знаходиться над скарбом, і `Entities.Hedge` у будь-якому іншому місці лабіринту.

Лабіринти не містять жодних петель, якщо тільки ви не використовуєте лабіринт повторно (дивіться нижче, як це зробити). Таким чином, дрон не може опинитися в тій же позиції знову, не повертаючись назад.

Ви можете перевірити наявність стіни, спробувавши пройти крізь неї. 
`move()` повертає `True`, якщо переміщення вдалося, і `False` у іншому випадку.

`can_move()` можна використовувати, щоб перевірити наявність стіни без руху.

Якщо ви не знаєте, як дістатися до скарбу, погляньте на Підказку 1. Вона показує, як підходити до такої задачі.

Використання `measure()` у будь-якому місці лабіринту повертає позицію скарбу.
`x, y = measure()`

Для додаткового виклику ви також можете повторно використати лабіринт, знову використавши таку ж кількість `Items.Weird_Substance` на скарбі. 
Це збере скарб і створить новий скарб у випадковому місці лабіринту.

Кожного разу, коли скарб переміщується, деякі стіни лабіринту можуть бути випадково видалені. Тож повторно використані лабіринти можуть містити петлі.

Зверніть увагу, що петлі в лабіринті роблять його набагато складнішим, оскільки це означає, що ви можете потрапити в те саме місце, не повертаючись назад.
Повторне використання лабіринту не дає вам більше золота, ніж просто збір врожаю та створення нового лабіринту.
Це на 100% додатковий челенж, який ви можете просто пропустити.
Це варто робити лише тоді, коли додаткова інформація допоможе вам швидше знайти скарб.

Скарб можна переміщувати до 300 разів. Після цього використання дивної субстанції на скарбі більше не збільшуватиме кількість золота в ньому, і він більше не рухатиметься.

<spoiler=show hint 1>Ось загальний підхід до вирішення проблеми:

Створіть лабіринт і уявіть, що ви — це дрон.

Подумайте про те, як би ви намагалися знайти скарб, якби були в лабіринті.

Запишіть свою стратегію крок за кроком так, щоб хтось інший міг слідувати їй, не замислюючись.

Тепер спробуйте перекласти ваші кроки в код.
</spoiler>
<spoiler=show hint 2>Поки немає петель: усі стіни насправді є лише однією великою з'єднаною стіною. Якщо ви будете йти вздовж стіни, вона проведе вас крізь увесь лабіринт.
Цей підхід вимагає дуже мало коду, і вам не потрібно відстежувати, де ви вже були. Близько 10 рядків коду — це все, що вам потрібно.</spoiler>
<spoiler=show hint 3>Замість того, щоб рухати дрона в абсолютних напрямках, таких як схід чи захід, може бути дуже корисно рухати його у відносних напрямках, наприклад «повернути праворуч» або «повернути ліворуч». Для цього вам потрібно стежити за тим, у якому напрямку зараз рухається дрон. Дрон ніколи насправді не обертається, але ви все одно можете підтримувати «віртуальне» обертання в коді.
Наступний трюк з індексами корисний для цього:

`directions = [North, East, South, West]`
`index = 0`

Використовуйте `% 4`, щоб дозволити йому обертатися «по колу», щоб після `West` він повернувся назад до `North`.
`# повернути праворуч`
`index = (index + 1) % 4`

`# повернути ліворуч`
`index = (index - 1) % 4`

`move(directions[index])`</spoiler>
<spoiler=show hint 4>Якщо ви не можете вирішити це завдання, ви завжди можете полегшити собі життя і зробити це менш ефективно. 
Пошук в лабіринті розміром `1`x`1` є тривіальним.</spoiler>
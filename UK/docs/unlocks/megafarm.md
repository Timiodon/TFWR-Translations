# Мегаферма
Це неймовірно потужне розблокування дає вам доступ до кількох дронів. 

Як і раніше, ви все ще починаєте лише з одного дрона. Додаткові дрони спочатку повинні бути створені і зникнуть після завершення програми.
Кожен дрон виконує власну окрему програму. Нові дрони можуть бути створені за допомогою функції `spawn_drone(function)`.

`def drone_function():`
`   move(North)`
`   do_a_flip()`

`spawn_drone(drone_function)`

Це створює нового дрона в тій же позиції, що й дрон, який запустив команду `spawn_drone(function)`. Новий дрон потім починає виконувати вказану функцію. Після завершення він автоматично зникне.

Дрони не стикаються один з одним. 

Використовуйте `max_drones()`, щоб отримати максимальну кількість дронів, які можуть існувати одночасно.
Використовуйте `num_drones()`, щоб отримати кількість дронів, які вже знаходяться на фермі.


## Приклад:
`def harvest_column():`
`   for _ in range(get_world_size()):`
`       harvest()`
`       move(North)`

`while True:`
`   if spawn_drone(harvest_column):`
`        move(East)`

Це змусить вашого першого дрона рухатися горизонтально і створювати нових дронів. Створені дрони будуть рухатися вертикально і збирати все на своєму шляху.

Якщо всі доступні дрони вже були створені, `spawn_drone()` нічого не зробить і поверне `None`.

Ось інший приклад, який передає різний напрямок кожному дрону:
`for dir in [North, East, South, West]:`
`   def task():`
`       move(dir)`
`       do_a_flip()`
`   spawn_drone(task)`

## Усі дрони рівні
Немає спеціального «головного» дрона. Усі дрони можуть створювати інших дронів, і всі вони враховуються до ліміту дронів. Усі дрони зникають, коли вони завершують роботу. Якщо перший дрон завершить свою програму раніше, інший дрон стане тим, чиє виконання візуалізується підсвічуванням коду. Усі дрони можуть активувати точки зупину (breakpoints), і коли дрон активує точку зупину, підсвічування коду перемикається на цього дрона.

<spoiler=show hint> Ознайомтеся з цією надзвичайно корисною паралельною функцією `for_all`, яка приймає будь-яку функцію та виконує її на кожній клітинці ферми. Вона використовує всіх доступних дронів для цього.

`def for_all(f):`
`   def row():`
`       for _ in range(get_world_size()-1):`
`           f()`
`           move(East)`
`       f()`
`   for _ in range(get_world_size()):`
`       if not spawn_drone(row):`
`           row()`
`       move(North)`

`for_all(harvest)`

Одним із особливо корисних шаблонів є створення дрона, якщо він доступний, і виконання завдання самостійно, якщо новий дрон не створюється.

`if not spawn_drone(task):`
`   task()`
</spoiler>

## Очікування на іншого дрона
Використовуйте функцію `wait_for(drone)`, щоб зачекати, поки інший дрон завершить роботу. Ви отримуєте ідентифікатор дрона, коли створюєте його за допомогою `spawn_drone`.
`wait_for(drone)` повертає значення, яке повернула функція, яку виконував інший дрон.

`def get_entity_type_in_direction(dir):`
`    move(dir)`
`    return get_entity_type()`

`def zero_arg_wrapper():`
`    return get_entity_type_in_direction(North)`
`drone = spawn_drone(zero_arg_wrapper)`
`print(wait_for(drone))`

Зверніть увагу, що створення дронів займає час, тому не варто створювати нового дрона для кожної дрібниці.

Ви можете використовувати `has_finished(drone)`, щоб перевірити, чи завершив роботу дрон, не чекаючи на нього.

## Відсутність спільної пам'яті
Кожен дрон має власну пам'ять і не може безпосередньо читати або писати в глобальні змінні іншого дрона.

`x = 0`

`def increment():`
`    global x`
`    x += 1`

`wait_for(spawn_drone(increment))`
`print(x)`

Це виведе `0`, оскільки новий дрон збільшив власну копію глобальної змінної `x`, що не впливає на `x` першого дрона.

## Стан гонитви (Race Conditions)
Кілька дронів можуть взаємодіяти з однією і тією ж клітинкою ферми одночасно. Якщо два дрони взаємодіють з однією клітинкою протягом одного тіку, відбудуться обидві взаємодії, але результати можуть відрізнятися залежно від порядку взаємодій.

Наприклад, уявіть, що дрони `0` та `1` обидва знаходяться над одним і тим же деревом, яке майже повністю виросло.
Дрон `0` викликає
`use_item(Items.Fertilizer)`
Дрон `1` викликає
`harvest()`

Якщо ці дії відбудуться одночасно, дерево спочатку буде удобрене, а потім зібране. У такому випадку ви отримаєте з нього деревину. Однак, якщо дрон `1` виявиться трохи швидшим, дерево буде зібрано до того, як воно буде удобрене, і ви не отримаєте деревину.
Це називається «стан гонитви» (race condition). Це поширена проблема в паралельному програмуванні, де результат залежить від порядку виконання операцій.

Ось інша проблемна ситуація, яка може статися, коли кілька дронів одночасно виконують той самий код в одній позиції.
`if get_water() < 0.5:`
`    use_item(Items.Water)`

Якщо кілька дронів запустять це одночасно, вони всі виконають перший рядок, що помістить їх у блок `if`. Потім вони всі використають воду, марно витрачаючи її велику кількість.
На той час, коли дрон дійде до другого рядка, `get_water()` може вже не бути меншим за `0.5`, тому що інший дрон тим часом полив клітинку.
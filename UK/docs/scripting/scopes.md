# Області видимості імен (Name Scopes)
Області видимості визначають, до яких змінних можна отримати доступ і звідки. Область видимості — це, по суті, зіставлення імен із їхніми значеннями.
Вони працюють так само, як у Python.

Існує глобальна область видимості, і кожна функція має свою локальну область видимості.
Коли ви визначаєте змінну, вона додається до поточної області видимості.
Усе, що знаходиться поза межами визначення функції, вважається частиною глобальної області видимості.

`x = 1`
Присвоює значення `1` імені `x` у глобальній області видимості.

Цей `def` присвоює функцію імені `f` у глобальній області видимості.
`def f():
    `Присвоює значення `1` імені `y` у локальній області видимості `f`.`
    y = 1

    `Присвоює функцію імені `g` у локальній області видимості функції `f`.`
    def g():
        pass`

`f()`
Отримує функцію, збережену в `f`, із глобальної області видимості та викликає її.

`print(y)`
Ця інструкція print у глобальній області видимості видасть помилку, оскільки `y` ніколи не була оголошена в глобальній області видимості, тому ми не можемо її тут прочитати.
Вона існувала лише в локальній області видимості `f`.

## Ключове слово global
За замовчуванням усі змінні у функціях прив’язуються до локальної області видимості, навіть якщо змінна з таким самим ім'ям існує в глобальній області видимості.

`x = 0

def f():
    x = 1
f()
print(x)`

Цей код надрукує `0`, оскільки локальна `x` всередині `f` не є тією ж змінною, що й глобальна `x`, тому глобальна `x` залишається незмінною. Це важливо, бо інакше виклик функції міг би випадково перезаписати глобальну змінну, ім'я якої випадково збіглося з локальною змінною цієї функції.

Якщо ви хочете записати значення в глобальну змінну, ви повинні зробити це явно, використовуючи ключове слово `global`.

`x = 0

def f():
    global x
    x = 1
f()
print(x)`

У цьому прикладі `global x` прив'язує `x` до глобальної змінної `x`, визначеної над нею. Тепер код надрукує `1`.
Зауважте, що зміна глобальних змінних зазвичай є першим кроком до «спагеті-коду», де кожна частина програми впливає на будь-яку іншу її частину, тому не зловживайте цим.

## Цикли та розгалуження
Цикли та розгалуження (умови) не створюють власних областей видимості, тому все, що оголошено всередині них, все одно можна використовувати ззовні.

`for i in range(3):
    pass
print(i)`

Це надрукує `2`, оскільки остання ітерація циклу `for` присвоїла `i` значення `2`.
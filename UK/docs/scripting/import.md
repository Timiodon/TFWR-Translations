# Імпорт (Import)
Тримати весь код в одному файлі швидко стає незручно. 
Інструкції `import` дозволяють імпортувати функції та глобальні змінні з іншого файлу.
Як це працює, на одному скриншоті:
![](ImportsInOnePicture400)

Тут `import module2` запускає файл із назвою `module2` і дає вам доступ до всіх його глобальних змінних.
Ви можете отримати доступ до змінних і функцій всередині імпортованого модуля за допомогою оператора `.`.
Отже, у цьому прикладі `module2.print_x()` викликає функцію `print_x()` з файлу `module2`.

### Далі можна не читати

Ви також можете перемістити глобальні змінні з імпортованого модуля в поточну область видимості, де виконується інструкція імпорту, використовуючи синтаксис `from`.

`from module2 import print_x
print_x()`
Імпортує лише вказані глобальні змінні з `module2`.

або

`from module2 import *
print_x()`
Імпортує всі глобальні змінні з `module2`.

Це також імпортує файл `module2`, але замість доступу до нього через змінну з назвою `module2`, воно «розпаковує» глобальні змінні з `module2` і присвоює їх безпосередньо в локальну область видимості.

Така форма імпорту зазвичай не рекомендується, оскільки вона погано працює, коли два файли імпортують один одного, і ви можете випадково перезаписати змінні в основному файлі через збіг імен. Безпечніше уникати синтаксису `from`, якщо ви не впевнені у своїх діях.

# Як це працює насправді

## Коротко про головне (TLDR)
Імпорт може бути досить неінтуїтивним, але більшості проблем можна уникнути, дотримуючись синтаксису `import file` замість `from file import` і загортаючи все, що не є визначенням глобальної змінної чи функції, у блок:
`if __name__ == "__main__":`

## Побічні ефекти імпорту
Коли ви вперше імпортуєте файл, він виконує весь вміст файлу, а потім дає вам доступ до всіх змінних, які були визначені під час виконання.
Якщо ви імпортуєте той самий файл знову, він просто поверне кешований модуль, отриманий першого разу.

Це означає, що інструкції імпорту можуть мати побічні ефекти. Якщо ви імпортуєте файл, який викликає `harvest()`, дрон справді збере врожай під час імпорту. Але коли ви імпортуєте його знову, він не буде збирати врожай, оскільки файл запускається лише один раз.

Є спосіб уникнути таких побічних ефектів за допомогою змінної `__name__`. Це змінна, яка автоматично встановлюється в `"__main__"`, коли файл запускається безпосередньо, і набуває імені файлу, коли файл запускається через `import`.
Вважається гарною практикою поміщати будь-який код, який ви не хочете запускати під час імпорту, всередину блоку `if __name__ == "__main__":`.

Поширеною структурою файлів у Python є розміщення коду, який має виконуватися під час запуску файлу, у функцію `main()`. Таким чином ви маєте чітке розмежування між локальними змінними (визначеними всередині `main()`) та глобальними змінними, які можна імпортувати (визначеними за межами `main()`).

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # виконуємо дії

if __name__ == "__main__":
    main()`

## Циклічні імпорти (Import Cycles)
Що станеться, якщо файл `a` імпортує файл `b`, а файл `b` імпортує файл `a`?

файл `a`:
`import b
x = 0`

файл `b`:
`import a
def f():
    print(a.x)`

Це працюватиме нормально. Припустимо, жоден із двох файлів ще не завантажений, і хтось інший виконує `import a`.

* `a` виконується до рядка `import b`.
* `b` виконується до рядка `import a`.
* Модуль `a` вже існує, але ще не містить `x`, оскільки він дійшов лише до рядка `import b`.
* `b` зберігає посилання на напівзавантажений модуль `a` у змінній з назвою `a`.
* `b` виконує інструкцію `def` і зберігає функцію `f()`.
* `a` продовжує виконання та ініціалізує `x`.

Коли хтось викличе `b.f()`, програма правильно надрукує `0`, оскільки модуль `a`, на який посилається `b`, тепер повністю завантажений.

Тепер розглянемо той самий код із використанням синтаксису `from`.

файл `a`:
`from b import *
x = 0`

файл `b`:
`from a import *
def f():
    print(x)`

* `a` виконується до рядка `from b import *`.
* `b` виконується до рядка `from a import *`.
* Модуль `a` вже існує, але ще не був повністю виконаний.
* `b` розпаковує все, що зараз є в `a`, у свою власну глобальну область видимості. На цей момент `a` нічого не містить, бо ще не дійшов до рядка `x = 0`, тому нічого не імпортується.
* `b` виконує інструкцію `def` і зберігає функцію `f()`.
* `a` продовжує виконання та ініціалізує `x`.

Якщо хтось тепер викличе `b.f()`, він отримає помилку, що `x` не існує в поточній області видимості. Це тому, що цього разу `b` не має посилання на `a`, який все ще завантажується, і не бачить визначень, які були додані після моменту імпорту.
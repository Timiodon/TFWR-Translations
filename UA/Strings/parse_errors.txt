@error_missing_default_parameter = Усі аргументи за замовчуванням повинні бути в кінці списку аргументів.
@error_invalid_name = {0} не є валідною назвою. Назви повинні починатись з літери та можуть містити лише літери, цифри та підкреслення. Також це не може бути зарезервованим ключовим словом.
@error_reserved_keyword = {0} є зарезервованим ключовим словом. Неможливо використати як назву.
@error_invalid_assign_expr = Неможливо присвоїти значення цьому виразу.
@error_no_statements = Блок коду повинен містити принаймні один оператор. 
Оператором може бути виклик функції, наприклад `harvest()`, або присвоювання змінній. 
Якщо бажаєте нічого не робити в блоці коду, використайте оператор `pass`.
@error_not_enough_indentation = Недостатньо відступів. 
Після : повинно бути більше відступів, ніж перед нею, щоб відокремити новий блок коду. 
Використовуйте клавішу Tab для створення відступів.
@error_too_much_indentation = Забагато відступів. 
Відступи мають бути однаковими для всіх операторів у межах одного блоку коду.
@error_not_a_statement = Це не є валідним оператором. 
@error_not_a_statement2 = Це не є валідним оператором. Можливо, ви мали на увазі {0} ?
@error_invalid_expression = Це не є валідним виразом.
@error_new_line_expected = Тут очікується новий рядок.
@error_unexpected_token = Тут очікується {0} .
@error_missing_colon = На початку кожного блоку коду повинна бути `:` .
@error_unexpected_assign = Тут неможливо використати присвоювання. Для перевірки рівності використовуйте `==`.
@error_invalid_for_syntax = Це не є валідним циклом for. Цикл for виглядає так: 
`for n in range(3):`
Після `for` завжди йде змінна циклу, потім `in` і послідовність. У цьому прикладі `n` — назва змінної, але її можна замінити на будь-яку.
@error_unknown_method = Цього методуне існує.
@error_bad_backslash = Зворотний слеш можна використовувати для розбиття виразів на кілька рядків. Після нього потрібно додати новий рядок.
@error_mixed_indentation = Не можна змішувати таби та пробіли.
@error_expected_close_token = Очікується кома або закриваюча дужка.
@error_wrong_dict_literal = Очікується : для розділення ключів і значень у словнику.
@error_assign_before_global = {0} присвоюється до оголошення global.
@error_wildcard_imports_not_allowed_in_function = Імпорти виду `from x import *` заборонені всередині функцій.
@error_invalid_import = Неможливо імпортувати файли з назвами, які не є валідними ідентифікаторами. Валідні ідентифікатори можуть містити лише літери, цифри та підкреслення. Якщо назва файлу містить інші символи, необхідно його перейменувати.
@error_invalid_number_format = Даний формат числа невалідний.
@error_compared_item_with_number = {0} не є числом, це предмет. Порівняння його з числом не має сенсу.

Якщо ви хочете перевірити, скільки цього предмета ви маєте, використовуйте `num_items(`{0}`)`.
@error_compared_entity_with_number = {0} не є числом, це сутність. Порівняння її з числом не має сенсу.
@error_compared_unlock_with_number = {0} не є числом, це розблокування. Порівняння його з числом не має сенсу.

Якщо ви хочете перевірити, скільки разів ви його розблокували, використовуйте `num_unlocked(`{0}`)`.
@error_nonsensical_or = Використання `or `{0} в умові не має сенсу, оскільки {0} є константою. 
Зверніть увагу, що оператори порівняння оцінюються перед `or`.

Приклад:
`x == 5 or 6` 
еквівалентно
`(x == 5) or 6`
Ненульові числа вважаються істинними, тому це еквівалентно
`(x == 5) or True`
що завжди істинно.

Це теоретично валідний код Python, але немає причин писати саме так.
@error_item_condition = {0} є предметом, а не булевим значенням. Використання його як умови не має сенсу. 
Можливо, ви хотіли перевірити, чи якесь значення дорівнює даному предмету?
`some_variable == `{0}
@error_unlock_condition = {0} є розблокуванням, а не булевим значенням. Використання його як умови не має сенсу. 
Ось як можна перевірити, чи розблокування активовано:
`num_unlocked(`{0}`) > 0`
@error_entity_condition = {0} є сутністю, а не булевим значенням. Використання її як умови не має сенсу.
Ось як можна перевірити тип сутності під дроном:
`get_entity_type() == `{0}
@error_ground_condition = {0} є типом ґрунту, а не булевим значенням. Використання його як умови не має сенсу.
Ось як можна перевірити тип ґрунту під дроном:
`get_ground_type() == `{0}